"""
Module to extend json module so it deals generically with objects.

Need to register your classes using register_TO_VALUE (method that converts object into something that is json serializable) and register_FROM_VALUE (method that converts appropriately labeled dict/list into your object)
Code is seeded with numpy.array, pandas.DataFrame, pandas.Series and paths.

Documentation  generated by chatGP3 on 2023-04-07

This is a module that extends the json module and allows it to generically deal with objects by providing methods to
convert objects into something that is JSON serializable and vice versa. The module is seeded with numpy arrays,
pandas DataFrames and Series, and paths.

The module provides four functions: dump, dumps, load, and loads. These functions are similar to the functions
provided by the json module, except that they use a custom JSON encoder, JSON_Encoder. The dump and dumps functions
serialize the input object to a file-like object or a string, respectively, using JSON_Encoder, while the load and
loads functions deserialize the input object from a file-like object or a string, respectively, using JSON_Encoder's
decode method.

The JSON_Encoder class provides the JSON encoding and decoding. It contains two class-level dictionaries,
TO_VALUE and FROM_VALUE. TO_VALUE is used to convert an object to something that can be serialized by JSON. It
contains a dictionary that maps the names of classes to functions that can be used to convert objects of those
classes to JSON serializable objects. The FROM_VALUE dictionary maps the names of classes to class methods that can
be used to create objects of those classes from JSON serializable objects.

The JSON_Encoder class also provides the register_TO_VALUE and register_FROM_VALUE methods to allow users to register
their own classes with the encoder. register_TO_VALUE is used to register a method that converts an object to a list
or dictionary, while register_FROM_VALUE is used to register a class method that generates an object from a list or
dictionary.

The value_to_obj method is a factory method that creates an object of a specified class using a dictionary. It takes
as input the name of the class to create and a dictionary of values to use to initialize the object. The obj_to_value
method converts an object to something that can be serialized by JSON. It takes as input an object and returns a
serialized version of the object.

"""
from __future__ import annotations

import json
import logging
import numpy as np
import pandas as pd
import pathlib
import typing

def dump(obj,fp,*args,**kwargs):
    """
    Dump object to file-like object fp. Uses JSON_Encoder to encode it. See json.dump() for documentation
    :param obj: Object to be dumped
    :param fp: File-like object
    *args -- args to be passed to json.dump
    **kwargs -- keyword arguments to be passed to json.dump
    :return -- result of json.dump
    """
    return json.dump(obj,fp,*args,cls=JSON_Encoder,**kwargs)

def dumps(obj, *args, **kwargs):
    """
    Dump object to str. Uses JSON_Encoder to encode it. See json.dumps() for documentation
    :param obj: Object to be dumped
    *args -- args to be passed to json.dumps
    **kwargs -- keyword arguments to be passed to json.dumps
    :return result of json.dumps
    """
    return json.dumps(obj, *args, cls=JSON_Encoder, **kwargs)

def load(fp, *args, **kwargs):
    """
    Load object from file-like object fp. Uses json.load() with object_hook set to JSON_Encoder.decode
    :param fp:
    :param args:
    :param kwargs:
    :return:
    """

    return json.load(fp, *args, object_hook=obj_to_from_dict.decode,**kwargs)


def loads(s, *args, **kwargs):
    """
    Decode object from s. Uses json.loads() with object_hook set to JSON_Encoder.decode.
    See json.loads for documentation
    :param s: thing to be decoded
    :param args: args to be passed to json.loads
    :param kwargs: kwargs to be passed to json.loads
    :return: result of json.loads
    """

    return json.loads(s, *args, object_hook=obj_to_from_dict.decode, **kwargs)

class obj_to_from_dict:
    """
    Provides JSON encoding and decoding for subsequent use.

    """
    #TODO: Make this support tuples and also keys that are not strings.
    FROM_VALUE = dict(ndarray=np.array,
                      DataFrame=pd.read_json,
                      Series=lambda x: pd.read_json(x,typ='series'),
                      Path=pathlib.Path,
                      WindowsPath=pathlib.Path,
                      PosixPath=pathlib.Path,
                      set=set)
    # functions to convert value to object. These should be "factory"  classmethods

    TO_VALUE = dict(ndarray=np.ndarray.tolist,
                    DataFrame=pd.DataFrame.to_json,
                    Series=pd.Series.to_json,
                    Path = str,WindowsPath=str,
                    PosixPath=str,
                    set=list) # functions to convert object to serializable object.
    #TODO when needed add support for datetime

    @classmethod
    def register_TO_VALUE(cls, mycls,method):
        """
        Register object method that converts an object to a list or dictionary
        :param method: method to convert
        :return:Nothing
        """
        name = mycls.__name__
        cls.TO_VALUE[name] = method
        logging.info(f"Registered {method.__qualname__} for {name} in TO_VALUE")
    @classmethod
    def register_FROM_VALUE(cls, mycls,classmethod):
        """
        Register class method that generates object from list or dict.
        :param mycls: class for which classmethod comes from.
        :param classmethod: class method to be registered
        :return:
        """
        name = mycls.__name__
        cls.FROM_VALUE[name] = classmethod
        logging.info(f"Registered {classmethod.__qualname__} for {name} in FROM_VALUE")
    @classmethod
    def value_to_obj(cls, class_name: str, values: dict | list):
        """
        Factory method to create object of type class_name using a dict
        :param class_name: Name of the class to create
        :param values: values to use to initialise object with
        :return: object
        """
        conv_fn = cls.FROM_VALUE.get(class_name)

        if conv_fn is None: # failed ot find conversion function.
            errMsg = f"Did not find {class_name}. Allowed classes are " + " ".join(cls.FROM_VALUE.keys())
            raise KeyError(errMsg)

        obj = conv_fn(values)
        logging.debug(f"Created a {class_name} object from {values}")
        return obj


    @classmethod
    def obj_to_value(cls, obj):
        """
        Convert an object to something that can be serialized by json.
        :param obj: object to convert
        :return: serialized version of object. If object class has not been registered a KeyError will be raised
        """

        name = obj.__class__.__name__
        try:
            method = cls.TO_VALUE[name]
        except KeyError:
            errMsg = f"Did not find {name}. Allowed classes are " + " ".join(cls.TO_VALUE.keys())
            raise TypeError(errMsg)

        result = method(obj)
        logging.debug(f"Converted {name} to {result} using {method.__name__}")
        return result

    @classmethod
    def decode(cls, dct):
        """
        Decode dct
        :param dct: dict to be decoded.

        If dct contains the key __cls__name__ then it will be decoded using value_to_obs.
        If not dct will be returned as no decoding neeed.

         Dct, for decoding,  should be of the form:
        {
            "__cls__name__" : "class_name",
            "object" : Stuff to be decoded
        }
        ValueError will be raised if the dct is not of this form.
        :return: input dct (if no decoding needed) or a decoded object.
        """

        if "__cls__name__" in dct.keys():
            name = dct.pop("__cls__name__")
            data = dct.pop("object")
            if len(dct) > 0:
                raise TypeError("Invalid dct")
            obj = cls.value_to_obj(name, data)
            logging.debug(f"Created a {name} object {obj}")

            return obj
        else:
            return dct

class JSON_Encoder(json.JSONEncoder):
    def default(self, obj) :
        """
        Called by json serialization
        :param obj: Any object

        :return: Serialised object packaged in a two element dict with the following key/value pairs:

         "__cls__name__" : name of the class of the object.
         "object": the serialized version of the object

        Also see decode which reverses this.
        """
        try:
            result = dict(__cls__name__=obj.__class__.__name__, object=obj_to_from_dict.obj_to_value(obj))
            return result
        except TypeError:
            try:
                super().default(obj)
            except TypeError: # something gone wrong. Say what!
                print(f"Failed to serialize {obj} of type{obj} and class {obj.__class__.__name__}")
                print(f"Know about {' '.join(list(obj_to_from_dict.FROM_VALUE.keys()))}")
                raise
