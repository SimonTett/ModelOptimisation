"""
Module to extend json module so it deals generically with objects.

Need to register your classes using register_TO_VALUE (method that converts object into something that is json serializable) and register_FROM_VALUE (method that converts appropriately labeled dict/list into your object)
Code is seeded with numpy.array, pandas.DataFrame, pandas.Series and paths.

Documentation  generated by chatGP3 on 2023-04-07

This is a module that extends the json module and allows it to generically deal with objects by providing methods to
convert objects into something that is JSON serializable and vice versa. The module is seeded with numpy arrays,
pandas DataFrames and Series, and paths.

The module provides four functions: dump, dumps, load, and loads. These functions are similar to the functions
provided by the json module, except that they use a custom JSON encoder, JSON_Encoder. The dump and dumps functions
serialize the input object to a file-like object or a string, respectively, using JSON_Encoder, while the load and
loads functions deserialize the input object from a file-like object or a string, respectively, using JSON_Encoder's
decode method.

The JSON_Encoder class provides the JSON encoding and decoding. It contains two class-level dictionaries,
TO_VALUE and FROM_VALUE. TO_VALUE is used to convert an object to something that can be serialized by JSON. It
contains a dictionary that maps the names of classes to functions that can be used to convert objects of those
classes to JSON serializable objects. The FROM_VALUE dictionary maps the names of classes to class methods that can
be used to create objects of those classes from JSON serializable objects.

The JSON_Encoder class also provides the register_TO_VALUE and register_FROM_VALUE methods to allow users to register
their own classes with the encoder. register_TO_VALUE is used to register a method that converts an object to a list
or dictionary, while register_FROM_VALUE is used to register a class method that generates an object from a list or
dictionary.

The value_to_obj method is a factory method that creates an object of a specified class using a dictionary. It takes
as input the name of the class to create and a dictionary of values to use to initialize the object. The obj_to_value
method converts an object to something that can be serialized by JSON. It takes as input an object and returns a
serialized version of the object.

"""
#TODO -- for numpy arrays. Write out the dtype, size and then conver the array to bytes.
#  for reading undo this.  Generalise to pandas objects? That way precision will be retained.
# but probably requires some hacking -- call the to_json function and thne replace the data cpt
# with the byte representation,
from __future__ import annotations

import copy
import json
import logging
import numpy as np
import pandas as pd
import pathlib
import importlib # so we can do imports
import typing
from io import StringIO
my_logger = logging.getLogger("OPTCLIM."+__name__) # logging for generic_json
type_error = typing.Literal['raise','warn','ignore']

def dump(obj,fp,*args,**kwargs):
    """
    Dump object to file-like object fp. Uses JSON_Encoder to encode it. See json.dump() for documentation
    :param obj: Object to be dumped
    :param fp: File-like object
    *args -- args to be passed to json.dump
    **kwargs -- keyword arguments to be passed to json.dump
    :return -- result of json.dump
    """
    return json.dump(obj,fp,*args,cls=JSON_Encoder,**kwargs)

def dumps(obj, *args, **kwargs):
    """
    Dump object to str. Uses JSON_Encoder to encode it. See json.dumps() for documentation
    :param obj: Object to be dumped
    *args -- args to be passed to json.dumps
    **kwargs -- keyword arguments to be passed to json.dumps
    :return result of json.dumps
    """
    return json.dumps(obj, *args, cls=JSON_Encoder, **kwargs)

def load(fp, *args,error:type_error='raise', **kwargs):
    """
    Load object from file-like object fp. Uses json.load() with object_hook set to JSON_Encoder.decode
    :param fp: file pointer to read.
    :param args:args to be passed to json.load
    :param kwargs:kwards to be passed to json.load
    :return:
    """
    decode_obj = obj_to_from_dict(error=error) # create decode object
    return json.load(fp, *args, object_hook=decode_obj.decode,**kwargs) # and use it


def loads(s, *args, error:type_error ='raise', **kwargs):
    """
    Decode object from s. Uses json.loads() with object_hook set to JSON_Encoder.decode.
    See json.loads for documentation
    :param s: thing to be decoded
    :param args: args to be passed to json.loads
    :param kwargs: kwargs to be passed to json.loads
    :return: result of json.loads
    """
    decode_obj = obj_to_from_dict(error=error)
    return json.loads(s, *args, object_hook=decode_obj.decode, **kwargs)

def dict2df(x:dict):
    """
    Convert a dict or str to a pandas DataFrame
    :param x: dict to convert
    :return: DataFrame
    """
    if isinstance(x,dict):
        result = pd.DataFrame.from_dict(x)
        try:
            index = pd.to_numeric(result.index)
        except ValueError: # failed to convert to leave as is.
            index = result.index
        try:
            rng_index = pd.RangeIndex(index.min(), index.max()+1)
            delta = np.abs(index - rng_index).max()
            if delta == 0:
                result.index = rng_index
                my_logger.debug('make_pandas_df setting RangeIndex')
        except (ValueError,TypeError):
            result.index = index
        return result

    elif isinstance(x,str):
        return pd.read_json(StringIO(x))
    else:
        raise TypeError(f"Cannot convert {x} to DataFrame")

def dict2series(x):
    """
    Convert a dict or str to a pandas series
    :param x: dict to convert
    :return: DataFrame
    """
    if isinstance(x,dict):
        return pd.Series(x['series'],index=x['index']).rename(x['name'])
    elif isinstance(x,str):
        return pd.read_json(StringIO(x),typ='series')
    else:
        raise TypeError(f"Cannot convert {x} to Series")
def conv_ndarray(x:dict):
    result = np.array(x['data'],dtype=x['typ'])
    return result

class obj_to_from_dict:
    """
    Provides JSON encoding and decoding for subsequent use.

    """
    #TODO: Make this support tuples and also keys that are not strings.
    #TODO: deal with provisional. For this version ignore it.
    #TODO: have this be versionable. With some name read from the saved json file or passed in??


    FROM_VALUE = dict(#ndarray=lambda x: np.array(x['data'],dtype=x['typ']),
                      ndarray=conv_ndarray,
                      DataFrame= dict2df,
                      Series=dict2series,
                      Path=pathlib.Path,
                      PurePosixPath=pathlib.PurePosixPath,
                      PureWindowsPath=pathlib.PureWindowsPath,
                      WindowsPath=pathlib.Path,
                      PosixPath=pathlib.Path,
                      set=set)
    # functions to convert value to object. These should be "factory"  classmethods

    TO_VALUE = dict(
        ndarray=lambda x: dict(data=x.tolist(), typ=str(x.dtype)),
        DataFrame=lambda x: x.to_dict(),  # liangwj
        Series=lambda x: dict(name=x.name, series=x.values, index=x.index.to_list()),
        Path = str,
        PurePosixPath=str,
        PureWindowsPath=str,
        WindowsPath=str,
        PosixPath=str,
        set=list)
    # functions to convert object to serializable object.
    #TODO when needed add support for datetime

    def __init__(self,error:type_error='raise'):
        self.error = error



    @classmethod
    def register_TO_VALUE(cls, mycls,method):
        """
        Register object method that converts an object to a list or dictionary
        :param method: method to convert
        :return:Nothing
        """
        name = mycls.__name__
        cls.TO_VALUE[name] = method
        my_logger.info(f"Registered {method.__qualname__} for {name} in TO_VALUE")
    @classmethod
    def register_FROM_VALUE(cls, mycls,classmethod):
        """
        Register class method that generates object from list or dict.
        :param mycls: class for which class method comes from.
        :param classmethod: class method to be registered
        :return:
        """
        name = mycls.__name__
        cls.FROM_VALUE[name] = classmethod
        my_logger.info(f"Registered {classmethod.__qualname__} for {name} in FROM_VALUE")

    def value_to_obj(self, class_name: str, values: dict | list):
        """
        Factory method to create object of type class_name using a dict
        :param class_name: Name of the class to create
        :param values: values to use to initialise object with
        :return: object
        """
        conv_fn = self.FROM_VALUE.get(class_name)

        if conv_fn is None: # failed to find conversion function.
            errMsg = f"Did not find {class_name}. Allowed classes are " + " ".join(self.FROM_VALUE.keys())
            if self.error == 'warn':
                my_logger.warning(errMsg)
                return None
            elif self.error == 'ignore':
                my_logger.debug(errMsg)
                return None

            raise KeyError(errMsg)

        obj = conv_fn(values)
        my_logger.debug(f"Created a {class_name} object from {values}")
        return obj


    @classmethod
    def obj_to_value(cls, obj):
        """
        Convert an object to something that can be serialized by json.
        :param obj: object to convert
        :return: serialized version of object. If object class has not been registered a KeyError will be raised
        """

        name = obj.__class__.__name__
        try:
            method = cls.TO_VALUE[name]
        except KeyError:
            errMsg = f"Did not find {name}. Allowed classes are " + " ".join(cls.TO_VALUE.keys())
            raise TypeError(errMsg)

        result = method(obj)
        my_logger.debug(f"Converted {name} to {result} using {method.__name__}")
        return result


    def decode(self, dct):
        """
        Decode dct
        :param dct: dict to be decoded.

        If dct contains the key __cls__name__ then it will be decoded using value_to_obs.
        If not dct will be returned as no decoding neeed.

         Dct, for decoding,  should be of the form:
        {
            "__cls__name__" : "class_name",
            "object" : Stuff to be decoded
        }
        ValueError will be raised if the dct is not of this form.
        :return: input dct (if no decoding needed) or a decoded object.
        """

        if "__cls__name__" in dct.keys():
            expect_count=2
            name = dct["__cls__name__"]
            module = dct.get("__module__",None)
            if module is not None: # have a module. Let's try and import it.
                my_logger.info(f"importing {module}")
                mod = importlib.import_module(module)
                expect_count=3
                # TODO check that mod has what we need. The reason for the import is to give us the decode methods...

            data = dct["object"]
            if len(dct) != expect_count:
                raise TypeError("Invalid dct")

            obj = self.value_to_obj(name, data)
            my_logger.debug(f"Created a {name} object {obj}")

            return obj
        else:
            return dct


    def rename_paths(self,dct_lst: typing.Union[dict, list],
                   rewrite_paths: dict) -> typing.Union[dict, list]:
        """
        Recursively rename the paths elements of a dict or list produced by generic_json.
        :param dct_lst:dict or list.
        :param rewrite_paths: paths to rewrite.
        Key is part for existing path to be made relative to and value is the new root.
        :return: renamed dict or list
        """
        if not isinstance(dct_lst, (dict, list)):
            raise TypeError(f'dct_lst should be a dict or list not {type(dct_lst)}')
        result = copy.copy(dct_lst)  # nb shallow copy
        if isinstance(dct_lst, dict) and (dct_lst.get('object') is not None):  # we are an encoded object
            obj = dct_lst['object']
            cls = dct_lst['__cls__name__']
            if isinstance(obj, (dict, list)):  # keep descending as need to convert
                rewrite_leaves = self.rename_paths(obj, rewrite_paths)
                result['object'] = rewrite_leaves
            elif cls in ['PosixPath', 'WindowsPath', 'PurePosixPath', 'PureWindowsPath','Path','PurePath']:
                path = pathlib.PurePath(obj)
                for k, v in rewrite_paths.items():
                    try:
                        new_path = v / path.relative_to(k)
                        result['object'] = str(new_path)
                        if cls.startswith('Pure'):
                            result['__cls__name__'] = 'PurePath'
                        else:
                            result['__cls__name__'] = 'Path'
                        my_logger.debug(f'Rewrote {path} to {new_path}')
                        break  # stop converting once we have been successful.
                    except ValueError:
                        pass
            else:
                pass  # no change made.
        elif isinstance(dct_lst, dict):
            for k, v in dct_lst.items():
                if isinstance(v, (dict, list)):
                    result[k] = self.rename_paths(v, rewrite_paths)
                else:
                    pass
        elif isinstance(dct_lst, list):
            result = list()
            for v in dct_lst:
                if isinstance(v, (dict, list)):
                    result.append(self.rename_paths(v, rewrite_paths))
                else:
                    result.append(v)

        else:
            pass
        # return the result.
        return result
    def dct_lst_to_obj(self,dct_lst: typing.Union[dict, list]) -> typing.Any:
        """
      Recursively decode a dict containing appropriate meta-data to an object.
      If dict has 'object' and '__class__name__' keys
      then conversion will occur.
        :param dct_lst: dict or list to be converted.
        :return: converted dct_lst to object.
        """
        if isinstance(dct_lst, dict) and (dct_lst.get('object') is not None):  # we are an encoded object
            obj = dct_lst['object']
            if isinstance(obj, (dict, list)):  # keep descending as need to convert
                decode_leaves = self.dct_lst_to_obj(obj)
                result = copy.deepcopy(dct_lst)  # nb shallow copy
                result['object'] = decode_leaves
                result = self.decode(result)
            else:  # just decode it
                result = self.decode(dct_lst)
        elif isinstance(dct_lst, dict):  # need to recurse but no decode at this level.
            result = dict()
            for k, v in dct_lst.items():
                result[k] = self.dct_lst_to_obj(v)

        elif isinstance(dct_lst, list):
            result = list()
            for v in dct_lst:
                result.append(self.dct_lst_to_obj(v))
        else:
            result = dct_lst

        return result

class JSON_Encoder(json.JSONEncoder):
    def default(self, obj) :
        """
        Called by json serialization
        :param obj: Any object

        :return: Serialised object packaged in a three element dict with the following key/value pairs:

         "__cls__name__" : name of the class of the object.
         "__module__" : name of the module where class is defined
         "object": the serialized version of the object

        Also see decode which reverses this.
        """
        try:

            result = dict(__cls__name__=obj.__class__.__name__,
                          object=obj_to_from_dict.obj_to_value(obj))
            # potentially add a module in to allow auto import. Numpy objects do not have a __module__ attribute
            try:
                module = obj.__module__
                result["__module__"]=module
            except AttributeError: # no module attribute
                pass
            return result
        except TypeError:
            try:
                super().default(obj)
            except TypeError: # something gone wrong. Say what!
                print(f"Failed to serialize {obj} of type{obj} and class {obj.__class__.__name__}")
                print(f"Know about {' '.join(list(obj_to_from_dict.FROM_VALUE.keys()))}")
                raise
